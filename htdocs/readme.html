<html>
  <head>
    <title>Python for .NET</title>
    <style type="text/css"><!--

body { 
  font: 8pt/16pt georgia,verdana; 
  text-decoration: none;
  color: #555753; 
  background: #ffffff;
  margin: 0px; 
}

p { 
  font: 8pt/16pt georgia; 
}

h1 { 
  font: bold 14pt;
  color: #000044;
/*
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
*/
}

h2 { 
  font: bold 14pt;
  margin-bottom: 0px; 
  color: #000044;
}

h3 { 
  font: bold 12pt;
  margin-bottom: 0px;
  color: #000044; 
}

a:link { 
  font-weight: bold; 
  text-decoration: none; 
  color: #000066;
}

a:visited { 
  font-weight: bold; 
  text-decoration: none; 
  color: #000066;
}

a:hover, a:active { 
  text-decoration: underline; 
  color: #000066;
}

pre {
  font-family: monospace;
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
}

li { 
  font: 8pt/16pt georgia,verdana; 
  text-decoration: none;
  color: #555753; 
}

.spacer {
  font: bold 14pt;
}

.menu {
  background-color: #EFEFFF;
  color: #000044;
  border-style: solid;
  border-width: 1px;
  border-color: #555753;
  padding: 6px, 2px, 6px, 2px;
  font-size: x-small;
}

.menu ul {
  margin: 0px;
  padding: 0px;
}

//--></style>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  </head>
  <body>
    <table border="0" cellspacing="4" width="98%">
      <tbody>
        <tr>
          <td class="menu" align="left" valign="top" width="20%">
            <h1>Python for .NET</h1>
            <ul>
              <li><a href="#installation">Installation</a></li>
              <li><a href="#getting_started">Getting Started</a></li>
              <li><a href="#importing">Importing Modules</a></li>
              <li><a href="#classes">Using Classes</a></li>
              <li><a href="#generics">Using Generics</a></li>
              <li><a href="#fields">Fields and Properties</a></li>
              <li><a href="#indexers">Using Indexers</a></li>
              <li><a href="#methods">Using Methods</a></li>
              <li><a href="#genericmethods">Overloaded and Generic Methods</a></li>
              <li><a href="#delegates">Delegates and Events</a></li>
              <li><a href="#exceptions">Exception Handling</a></li>
              <li><a href="#arrays">Using Arrays</a></li>
              <li><a href="#collections">Using Collections</a></li>
              <li><a href="#com">COM Components</a></li>
              <li><a href="#types">Type Conversion</a></li>
              <li><a href="#embedding">Embedding Python</a></li>
              <li><a href="#license">License</a></li>
            </ul>
          </td>
          <td align="left" valign="top">
            <p> Python for .NET is a package that gives Python programmers
              nearly seamless integration with the .NET Common Language Runtime
              (CLR) and provides a powerful application scripting tool for .NET
              developers. Using this package you can script .NET applications or
              build entire applications in Python, using .NET services and
              components written in any language that targets the CLR (Managed
              C++, C#, VB, JScript).
            </p>
            <p> Note that this package does <em>not</em> implement Python as a
              first-class CLR language - it does not produce managed code (IL)
              from Python code. Rather, it is an integration of the C Python
              engine with the .NET runtime. This approach allows you to use use
              CLR services and continue to use existing Python code and C-based
              extensions while maintaining native execution speeds for Python
              code. If you are interested in a pure managed-code implementation
              of the Python language, you should check out the <a href="http://www.ironpython.com">IronPython</a>
              project, which is in active development.
            </p>
            <p> Python for .NET is currently compatible with Python releases 2.3
              and greater. Current releases are available at the <a href="http://pythonnet.sourceforge.net/">
                Python for .NET website </a>. To subscribe to the <a href="http://mail.python.org/mailman/listinfo/pythondotnet">
                Python for .NET mailing list </a> or read the <a href="http://mail.python.org/pipermail/pythondotnet/">
                online archives </a> of the list, see the <a href="http://mail.python.org/mailman/listinfo/pythondotnet">
                mailing list information </a> page. </p>
            <a name="#installation"></a>
            <h2>Installation</h2>
            <p> Python for .NET is available as a source release and as a
              Windows installer for various versions of Python and the common
              language runtime from the <a href="http://pythonnet.sourceforge.net/">
                Python for .NET website </a>. On Windows platforms, you can
              choose to install .NET-awareness into an existing Python
              installation as well as install Python for .NET as a standalone
              package.
            </p>
            
            <p> The source release is a self-contained "private" assembly. Just
              unzip the package wherever you want it, cd to that directory and
              run python.exe to start using it. Note that the source release
              does not include a copy of the CPython runtime, so you will need
              to have installed Python on your machine before using the source
              release.
            </p>
            <p> <strong>Running on Linux/Mono:</strong> preliminary testing
              shows that PythonNet will run under <a href="http://www.go-mono.com">Mono</a>,
              though the Mono runtime is not yet complete so there still may be
              problems. The Python for .NET integration layer is 100% managed
              code, so there should be no long-term issues under Mono - it
              should work better and better as the Mono platform matures.
            </p>
            <p> Note that if you are running under Mono on a *nix system, you
              will need to have a compatible version of Python installed. You
              will also need to create a symbolic link to the copy of
              libpython2.x.so (in your existing Python installation) in the
              PythonNet directory. This is needed to ensure that the mono
              interop dll loader will find it by name. For example:
            </p>
            <pre>    ln -s /usr/lib/libpython2.4.so ./python24.so
</pre>
            <a name="getting_started"></a>
            <h2>Getting Started</h2>
            <p> A key goal for this project has been that Python for .NET should
              "work just the way you'd expect in Python", except for cases that
              are .NET specific (in which case the goal is to work "just the way
              you'd expect in C#"). In addition, with the IronPython project
              gaining traction, it is my goal that code written for IronPython
              run without modification under Python for .NET.
            </p>
            <p> If you already know Python, you can probably finish this readme
              and then refer to .NET docs to figure out anything you need to do.
              Conversely if you are familiar with C# or another .NET language,
              you probably just need to pick up one of the many good Python
              books or read the Python tutorial online to get started.
            </p>
            <p> A good way to start is to run <strong>python.exe</strong> and
              follow along with the examples in this document. If you get stuck,
              there are also a number of demos and unit tests located in the
              source directory of the distribution that can be helpful as
              examples.
            </p>
            <p> Note that if you have installed CLR support into your existing
              Python installation (rather than using the included python.exe),
              you will need to use the line: "'import clr" (lower-case!) to
              initially load the clr extension module before trying the
              following examples.
            </p>
            <a name="importing"></a>
            <h2>Importing Modules</h2>
            <p> Python for .NET allows CLR namespaces to be treated essentially
              as Python packages. </p>
            <p>
            </p>
            <pre>    from System import String
    from System.Collections import *
</pre>
            <p>
              <em> Note that earlier releases of Python for .NET required you to
                import modules through a special top-level package named <code>CLR</code>.
                This is no longer required if you are starting python from the
                managed python.exe from this distribution.<br>
                <code>CLR</code> has been deprecated in favor of the more
                pythonic <code>clr</code>, though the syntax is still supported
                for backward compatibility.
              </em>
            </p>
            <p> Types from any loaded assembly may be imported and used in this
              manner. To load an assembly, use the "AddReference" function in
              the "clr" module:
            </p>
            <pre>
    import clr
    clr.AddReference("System.Windows.Forms")
    from System.Windows.Forms import Form

</pre>
            <p>
              <em> Note that earlier releases of Python for .NET relied on
                "implicit loading" to support automatic loading of assemblies
                whose names corresponded to an imported namespace. Implicit
                loading still works for backward compatibility, but will be
                removed in a future release so it is recommended to use the
                clr.AddReference method.
              </em>
            </p>
            <p> Python for .NET uses the PYTHONPATH (sys.path) to look for
              assemblies to load, in addition to the usual application base and
              the GAC. To ensure that you can implicitly import an assembly, put
              the directory containing the assembly in <code>sys.path</code>.
            </p>
            <a name="classes"></a>
            <h2>Using Classes</h2>
            <p> Python for .NET allows you to use any non-private classes,
              structs, interfaces, enums or delegates from Python. To create an
              instance of a managed class, you use the standard instantiation
              syntax, passing a set of arguments that match one of its public
              constructors:
            </p>
            <pre>    from System.Drawing import Point

    p = Point(5, 5)
</pre>
            <p> In most cases, Python for .NET can determine the correct
              constructor to call automatically based on the arguments. In some
              cases, it may be necessary to call a particular overloaded
              constructor, which is supported by a special "__overloads__"
              attribute, which will soon be deprecated in favor of iPy
              compatible "Overloads", on a class:
            </p>
            <pre>    from System import String, Char, Int32

    s = String.Overloads[Char, Int32]('A', 10)
    s = String.__overloads__[Char, Int32]('A', 10)
</pre>
            <a name="generics"></a>
            <h2>Using Generics</h2>
            <p> When running under versions of the .NET runtime greater than
              2.0, you can use generic types. A generic type must be bound to
              create a concrete type before it can be instantiated. Generic
              types support the subscript syntax to create bound types:
            </p>
            <pre>    from System.Collections.Generic import Dictionary
    from System import *

    dict1 = Dictionary[String, String]()
    dict2 = Dictionary[String, Int32]()
    dict3 = Dictionary[String, Type]()
</pre>
            <p> When you pass a list of types using the subscript syntax, you
              can also pass a subset of Python types that directly correspond to
              .NET types:
            </p>
            <pre>    dict1 = Dictionary[str, str]()
    dict2 = Dictionary[str, int]()
    dict3 = Dictionary[str, Decimal]()
</pre>
            <p> This shorthand also works when explicitly selecting generic
              methods or specific versions of overloaded methods and
              constructors (explained later).
            </p>
            <p> You can also subclass managed classes in Python, though members
              of the Python subclass are not visible to .NET code. See the <code>helloform.py</code>
              file in the <code>/demo</code> directory of the distribution for
              a simple Windows Forms example that demonstrates subclassing a
              managed class.
            </p>
            <a name="fields"></a>
            <h2>Fields And Properties</h2>
            <p> You can get and set fields and properties of CLR objects just as
              if they were regular attributes:
            </p>
            <pre>    from System import Environment

    name = Environment.MachineName
    Environment.ExitCode = 1
</pre>
            <a name="indexers"></a>
            <h2>Using Indexers</h2>
            <p> If a managed object implements one or more indexers, you can
              call the indexer using standard Python indexing syntax:
            </p>
            <pre>    from System.Collections import Hashtable

    table = Hashtable()
    table["key 1"] = "value 1"
</pre>
            <p> Overloaded indexers are supported, using the same notation one
              would use in C#:
            </p>
            <pre>    items[0, 2]

    items[0, 2, 3]
</pre>
            <a name="methods"></a>
            <h2>Using Methods</h2>
            <p> Methods of CLR objects behave generally like normal Python
              methods. Static methods may be called either through the class or
              through an instance of the class. All public and protected methods
              of CLR objects are accessible to Python:
            </p>
            <pre>    from System import Environment

    drives = Environment.GetLogicalDrives()
</pre>
            <p> It is also possible to call managed methods <code>unbound</code>
              (passing the instance as the first argument) just as with Python
              methods. This is most often used to explicitly call methods of a
              base class.
            </p>
            <p> <em>Note that there is one caveat related to calling unbound
                methods: it is possible for a managed class to declare a static
                method and an instance method with the same name. Since it is
                not possible for the runtime to know the intent when such a
                method is called unbound, the static method will always be
                called.</em>
            </p>
            <p> The docstring of CLR a method (__doc__) can be used to view the
              signature of the method, including overloads if the CLR method is
              overloaded. You can also use the Python <code>help</code> method
              to inspect a managed class:
            </p>
            <pre>    from System import Environment

    print Environment.GetFolderPath.__doc__

    help(Environment)
</pre>
            <a name="genericmethods"></a>
            <h2>Overloaded and Generic Methods</h2>
            <p> While Python for .NET will generally be able to figure out the
              right version of an overloaded method to call automatically, there
              are cases where it is desirable to select a particular method
              overload explicitly.
            </p>
            <p> Methods of CLR objects have an "__overloads__", which will soon
              be deprecated in favor of iPy compatible Overloads, attribute that
              can be used for this purpose :
            </p>
            <pre>    from System import Console

    Console.WriteLine.Overloads[bool](true)
    Console.WriteLine.Overloads[str]("true")
    Console.WriteLine.__overloads__[int](42)
</pre>
            <p> Similarly, generic methods may be bound at runtime using the
              subscript syntax directly on the method:
            </p>
            <pre>    someobject.SomeGenericMethod[int](10)
    someobject.SomeGenericMethod[str]("10")
</pre>
            <a name="delegates"></a>
            <h2>Delegates And Events</h2>
            <p> Delegates defined in managed code can be implemented in Python.
              A delegate type can be instantiated and passed a callable Python
              object to get a delegate instance. The resulting delegate instance
              is a true managed delegate that will invoke the given Python
              callable when it is called:
            </p>
            <pre>    def my_handler(source, args):
        print 'my_handler called!'

    # instantiate a delegate
    d = AssemblyLoadEventHandler(my_handler)

    # use it as an event handler
    AppDomain.CurrentDomain.AssemblyLoad += d
</pre>
            <p> Multicast delegates can be implemented by adding more callable
              objects to a delegate instance:
            </p>
            <pre>    d += self.method1
    d += self.method2
    d()
</pre>
            <p> Events are treated as first-class objects in Python, and behave
              in many ways like methods. Python callbacks can be registered with
              event attributes, and an event can be called to fire the event.
            </p>
            <p> Note that events support a convenience spelling similar to that
              used in C#. You do not need to pass an explicitly instantiated
              delegate instance to an event (though you can if you want). Events
              support the <code>+=</code> and <code>-=</code> operators in a
              way very similar to the C# idiom:
            </p>
            <pre>    def handler(source, args):
        print 'my_handler called!'

    # register event handler
    object.SomeEvent += handler

    # unregister event handler
    object.SomeEvent -= handler

    # fire the event
    result = object.SomeEvent(...)
</pre>
            <a name="exceptions"></a>
            <h2>Exception Handling</h2>
            <p> You can raise and catch managed exceptions just the same as you
              would pure-Python exceptions:
            </p>
            <pre>    from System import NullReferenceException

    try:
        raise NullReferenceException("aiieee!")
    except NullReferenceException, e:
        print e.Message
        print e.Source
</pre>
            <p></p>
            <a name="arrays"></a>
            <h2>Using Arrays</h2>
            <p> The type <code>System.Array</code> supports the subscript
              syntax in order to make it easy to create managed arrays from
              Python:
            </p>
            <pre>    from System import Array

    myarray = Array[int](10)
</pre>
            <p> Managed arrays support the standard Python sequence protocols:
            </p>
            <pre>    items = SomeObject.GetArray()

    # Get first item
    v = items[0]
    items[0] = v

    # Get last item
    v = items[-1]
    items[-1] = v

    # Get length
    l = len(items)

    # Containment test
    test = v in items
</pre>
            <p> Multidimensional arrays support indexing using the same notation
              one would use in C#:
            </p>
            <pre>    items[0, 2]

    items[0, 2, 3]
</pre>
            <a name="collections"></a>
            <h2>Using Collections</h2>
            <p> Managed arrays and managed objects that implement the
              IEnumerable interface can be iterated over using the standard
              iteration Python idioms:
            </p>
            <pre>    domain = System.AppDomain.CurrentDomain

    for item in domain.GetAssemblies():
        name = item.GetName()
</pre>
            <a name="com"></a>
            <h2>Using COM Components</h2>
            <p> Using Microsoft-provided tools such as <strong>aximp.exe</strong>
              and <strong>tlbimp.exe</strong>, it is possible to generate
              managed wrappers for COM libraries. After generating such a
              wrapper, you can use the libraries from Python just like any other
              managed code.
            </p>
            <p> Note: currently you need to put the generated wrappers in the
              GAC, in the PythonNet assembly directory or on the PYTHONPATH in
              order to load them.
            </p>
            <a name="types"></a>
            <h2>Type Conversion</h2>
            <p> Type conversion under Python for .NET is fairly straightforward
              - most elemental Python types (string, int, long, etc.) convert
              automatically to compatible managed equivalents (String, Int32,
              etc.) and vice-versa. Note that all strings returned from the CLR
              are returned as unicode.
            </p>
            <p> Types that do not have a logical equivalent in Python are
              exposed as instances of managed classes or structs (System.Decimal
              is an example).
            </p>
            <p> The .NET architecture makes a distinction between <code>value
                types</code> and <code>reference types</code>. Reference types
              are allocated on the heap, and value types are allocated either on
              the stack or in-line within an object.
            </p>
            <p> A process called <code>boxing</code> is used in .NET to allow
              code to treat a value type as if it were a reference type. Boxing
              causes a separate copy of the value type object to be created on
              the heap, which then has reference type semantics.
            </p>
            <p> Understanding boxing and the distinction between value types and
              reference types can be important when using Python for .NET
              because the Python language has no value type semantics or syntax
              - in Python "everything is a reference".
            </p>
            <p> Here is a simple example that demonstrates an issue. If you are
              an experienced C# programmer, you might write the following code:
            </p>
            <pre>    items = System.Array.CreateInstance(Point, 3)
    for i in range(3):
        items[i] = Point(0, 0)

    items[0].X = 1 # won't work!!
</pre>
            <p> While the spelling of <code>items[0].X = 1</code> is the same
              in C# and Python, there is an important and subtle semantic
              difference. In C# (and other compiled-to-IL languages), the
              compiler knows that Point is a value type and can do the Right
              Thing here, changing the value in place.
            </p>
            <p> In Python however, "everything's a reference", and there is
              really no spelling or semantic to allow it to do the right thing
              dynamically. The specific reason that <code>items[0]</code>
              itself doesn't change is that when you say <code>items[0]</code>,
              that getitem operation creates a Python object that holds a
              reference to the object at <code>items[0]</code> via a GCHandle.
              That causes a ValueType (like Point) to be boxed, so the following
              setattr (<code>.X = 1</code>) <em>changes the state of the boxed
                value, not the original unboxed value</em>.
            </p>
            <p> The rule in Python is essentially: "the result of any attribute
              or item access is a boxed value", and that can be important in how
              you approach your code.
            </p>
            <p> Because there are no value type semantics or syntax in Python,
              you may need to modify your approach. To revisit the previous
              example, we can ensure that the changes we want to make to an
              array item aren't "lost" by resetting an array member after making
              changes to it:
            </p>
            <pre>    items = System.Array.CreateInstance(Point, 3)
    for i in range(3):
        items[i] = Point(0, 0)

    # This _will_ work. We get 'item' as a boxed copy of the Point
    # object actually stored in the array. After making our changes
    # we re-set the array item to update the bits in the array.

    item = items[0]
    item.X = 1
    items[0] = item
</pre>
            <p> This is not unlike some of the cases you can find in C# where
              you have to know about boxing behavior to avoid similar kinds of <code>lost
                update</code> problems (generally because an implicit boxing
              happened that was not taken into account in the code).
            </p>
            <p> This is the same thing, just the manifestation is a little
              different in Python. See the .NET documentation for more details
              on boxing and the differences between value types and reference
              types.
            </p>
            <a name="embedding"></a>
            <h2>Embedding Python</h2>
            <p> <strong>Note:</strong> because Python code running under Python
              for .NET is inherently unverifiable, it runs totally under the
              radar of the security infrastructure of the CLR so you should
              restrict use of the Python assembly to trusted code.
            </p>
            <p> The Python runtime assembly defines a number of public classes
              that provide a subset of the functionality provided by the Python
              C API.
            </p>
            <p> These classes include PyObject, PyList, PyDict, etc. The source
              and the unit tests are currently the only API documentation.. The
              rhythym is very similar to using Python C++ wrapper solutions such
              as CXX.
            </p>
            <p> At a very high level, to embed Python in your application you
              will need to:
            </p>
            <ul>
              <li>Reference Python.Runtime.dll in your build environment</li>
              <li>Call PythonEngine.Intialize() to initialize Python</li>
              <li>Call PythonEngine.ImportModule(name) to import a module</li>
            </ul>
            <p> The module you import can either start working with your managed
              app environment at the time its imported, or you can explicitly
              lookup and call objects in a module you import.
            </p>
            <p> For general-purpose information on embedding Python in
              applications, use www.python.org or Google to find (C) examples.
              Because Python for .NET is so closely integrated with the managed
              environment, you will generally be better off importing a module
              and deferring to Python code as early as possible rather than
              writing a lot of managed embedding code.
            </p>
            <p> <strong>Important Note for embedders:</strong> Python is not
              free-threaded and uses a global interpreter lock to allow
              multi-threaded applications to interact safely with the Python
              interpreter. Much more information about this is available in the
              Python C API documentation on the www.python.org Website.
            </p>
            <p> When embedding Python in a managed application, you have to
              manage the GIL in just the same way you would when embedding
              Python in a C or C++ application.
            </p>
            <p> Before interacting with any of the objects or APIs provided by
              the Python.Runtime namespace, calling code must have acquired the
              Python global interpreter lock by calling the <code>PythonEngine.AcquireLock</code>
              method. The only exception to this rule is the <code>PythonEngine.Initialize</code>
              method, which may be called at startup without having acquired the
              GIL.
            </p>
            <p> When finished using Python APIs, managed code must call a
              corresponding <code>PythonEngine.ReleaseLock</code> to release
              the GIL and allow other threads to use Python.
            </p>
            <p> The AcquireLock and ReleaseLock methods are thin wrappers over
              the unmanaged <code>PyGILState_Ensure</code> and <code>PyGILState_Release</code>
              functions from the Python API, and the documentation for those
              APIs applies to the managed versions.
            </p>
            <a name="license">
              <h2>License</h2>
            </a>
            <p><a name="license"> Python for .NET is released under the open
                source Zope Public License (ZPL). A copy of the ZPL is included
                in the distribution, or you can find a copy of the </a><a href="http://pythonnet.sourceforge.net/license.txt">
                ZPL online </a>. Some distributions of this package include a
              copy of the C Python dlls and standard library, which are covered
              by the <a href="http://www.python.org/license.html"> Python
                license </a>.
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
